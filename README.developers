# -*- mode:org -*-
* Notes for modifying source

** GUI development

1. Use Qt4.8 designer. Label linedits and checkboxes correctly - give tooltip when appropriate
2. Convert ui to py: pyuic4 --output Agilent2DicomQt.py Agilent2DicomQt.ui
3. Modify Agilent2DicomAppQt.py

New filters/methods 
1. Create new method in cplxfilter/kspace_filter.py
2. Create new argument in fid2dicom.py
3. Create new arguments in fid2dcm.sh

** Global constants

=agilent2dicom_globalvars.py= is readable by shell and python.  Make
sure that there are no spaces between variable name, =, or the string
label.

#+BEGIN_SRC sh

AGILENT2DICOM_VERSION="1.6.4"
AGILENT2DICOM_APP_VERSION="1.8"
FDF2DCMVERSION="1.2"
FID2DCMVERSION="1.4"
#+END_SRC


** GUI update

After changing the QT gui in =designer= use the following line to update the python version:
#+BEGIN_SRC sh

pyuic4 --output Agilent2DicomQt.py Agilent2DicomQt.ui
#+END_SRC

** Mercurial keywords

Mercurial keyword expansion is used to set some handy
variables. The hgrc file in the development .hg folder should be the
following:

#+begin_src ascii

[paths]
default = ssh://hg@bitbucket.org/mbi-image/agilent2dicom
[extensions]
keyword =
[keyword]
agilent2dicom.py =
agilentFDF2dicom.py =
fdf2dcm.sh =
agilent2dicom_globalvars.py =
fid2dicom.py =
fid2dcm.sh =
Agilent2DicomApp.py =
Agilent2DicomAppQt.py =
[keywordmaps]
Author = {author|user}
Date = {date|utcdate}
Header = {root}/{file},v {node|short} {date|utcdate} {author|user}
Id = {file|basename},v {node|short} {date|utcdate} {author|user}
Revision = {node|short}
#+end_src


Use the kwexpand command to enable config tags to be filled correctly.
#+begin_src sh
hg kwexpand
#+end_src

** Sorting Procpar files for easy diff

*sortpp* alphabetises the procpar format for easier comparison using
diff.  The awk script pastes the label and value lines together, then
stores the string in an array.  The final output is sorted before
being printed.
#+begin_src sh
diff -y <(./sortpp <../ExampleAgilentData/kidney512iso_01.fid/procpar) <(./sortpp <../example_data/s_2014072901/T2-cor_01.fid/procpar)
#+end_src



* K space

Use ipython for interactive sessions with kspace_filter: 
#+begin_src sh
ipython -i ./kspace_filter.py -- -v -i ../ExampleAgilentData/kidney512iso_01.fid/ -o ../ExampleAgilentData/kidney512iso_01.dcm/ 
#+end_src



** Standard Gaussian

#+begin_src python
   kspgauss =kspacegaussian_filter2(ksp,256/0.707)
   image_filtered = fftshift(ifftn(ifftshift(kspgauss)))
   # print "Saving Gaussian image"
   save_nifti(normalise(np.abs(image_filtered)),'gauss_kspimage')
#+end_src

** Gaussian with sub-band1.5 

#+begin_src python
   print "Computing Gaussian sub-band1.5 image from Original image"
   kspsubband =fouriergausssubband15(ksp.shape,0.707/256)
   image_filtered = fftshift(ifftn(ifftshift(kspsubband)))
   # print "Saving Gaussian image"
   save_nifti(normalise(np.abs(image_filtered)),'gauss_subband')

#+end_src

** Inhomogeneous bias correction

#+begin_src python
   image_corr = inhomogeneousCorrection(ksp,ksp.shape,3.0/60.0)
   save_nifti(np.abs(image_filtered/image_corr),'image_inhCorr3')
#+end_src

** Enhanced laplacian 

   F{ D^2 f(x,y,z) } = (-2 pi k)^2 F(k)

#+begin_src python
   print "Computing Laplacian enhanced image"
   laplacian = fftshift(ifftn(ifftshift(kspgauss * fourierlaplace(ksp.shape))))
   alpha=ndimage.mean(np.abs(image_filtered))/ndimage.mean(np.abs(laplacian))
   image_lfiltered = image_filtered - 0.5*alpha*laplacian
   save_nifti(np.abs(image_lfiltered),'laplacian_enhanced')
#+end_src

** LoG - second-order edge detector/ blob detector    
#+begin_src python
   print "Computing Gaussian Laplace image from Smoothed image"
   ksplog=kspacelaplacegaussian_filter(ksp,256.0/0.707)
   image_filtered = fftshift(ifftn(ifftshift(ksplog)))
   image_filtered= (np.abs(image_filtered))
   image_filtered= (image_filtered-ndimage.minimum(image_filtered))/(ndimage.maximum(image_filtered) - ndimage.minimum(image_filtered))
   save_nifti(np.abs(image_filtered),'Log_image')
#+end_src

** Smoothed LoG 

#+begin_src python
  Flaplace = fourierlaplace(ksp.shape)
  #Flaplace = (Flaplace - ndimage.minimum(Flaplace))/(ndimage.maximum(Flaplace)-ndimage.minimum(Flaplace))
  Fsmooth =fouriergauss(ksp.shape,(4.0*np.sqrt(2.0*np.log(2.0)))/512.0)
  Fgauss = fouriergauss(ksp.shape,0.707/512)  # 
  laplacian = fftshift(ifftn(ifftshift(ksp * (Fgauss/ndimage.maximum(Fgauss)) * Flaplace * (Fsmooth/ndimage.maximum(Fsmooth)) )))
  smoothlaplacian = (laplacian - ndimage.minimum(laplacian))/(ndimage.maximum(laplacian)-ndimage.minimum(laplacian))
  print "Saving Smoothed Gauss Laplacian"
  save_nifti(np.abs(smoothlaplacian),'Log_smoothed')
  image_filtered = fftshift(ifftn(ifftshift(ksplog*Fsmooth)))
  save_nifti(np.abs(image_filtered),'Log_smoothed2')
#+end_src
    

** Double resolution
    
#+begin_src python
  test_double_resolution(kspgauss,'Gauss')
  test_double_resolution(ksplog,'LoG')
#+end_src

** Depth algorithm

#+begin_src python
  test_depth_algorithm(fftshift(ifftn(ifftshift(kspgauss))),'gauss_kspdepth')
  test_double_resolution_depth(kspgauss,'gauss_depth_large')
#+end_src 




* See Examples

https://scipy-lectures.github.io/advanced/image_processing/
https://scipy-lectures.github.io/packages/scikit-image/

using PIL
http://nbviewer.ipython.org/github/mroberts3000/GpuComputing/blob/master/
IPython/GaussianBlur.ipynb


http://www.lancs.ac.uk/~struijke/density/kernel.html
http://sfb649.wiwi.hu-berlin.de/fedc_homepage/xplore/ebooks/html/anr/anrhtmlframe33.html


* CYTHON 

** kspace filter 

*kspace_filter.py* has many bespoke ndarray operations that would be suitable for optimisation using cython


1. kspace_filter.py was copied to filterkspace.pyx
2. define data types in all the functions as per http://docs.cython.org/src/userguide/numpy_tutorial.html#numpy-tutorial

#+BEGIN_SRC python
from __future__ import division
import numpy as np
cimport numpy as np
...
DTYPE = np.int
NP_FLOAT = np.float32
NP_CMPLX = np.complex64
...
ctypedef np.int_t DTYPE_t
ctypedef np.float32_t NP_FLOAT_t
ctypedef np.complex64_t NP_CMPLX_t

...
def fouriercoords(np.ndarray siz):
...
    cdef np.ndarray sz = np.ceil(np.array(siz) / 2.0)
    cdef np.ndarray xx = np.array(range(-int(sz[0]), int(sz[0])))
    cdef np.ndarray yy = np.array(range(-int(sz[1]), int(sz[1])))
    cdef np.ndarray zz
    cdef DTYPE_t maxlen = ndimage.maximum(np.array(siz))
    cdef np.ndarray mult_fact, uu, vv, ww

#+END_SRC
 

3. Include type and size checks in each function

#+BEGIN_SRC python
    if siz.ndim != 1 and (siz.size != 3 or siz.size != 2):
        raise ValueError("Only 2D or 3D dimensions on filter supported")
    assert siz.dtype == DTYPE

#+END_SRC
4. Create a setup script (setup.py)
5. Include numpy headers for MASSIVE in filterkspace header
   _numpyconfig.h not found, even with *numpy.get_headers()* in setup.  Numpy build path put at top of filterkspace.pyx:
#+BEGIN_EXAMPLE
# distutils: include_dirs = /usr/local/src/PYTHON/NUMPY/numpy-1.7.0/numpy/core/include/ /usr/local/src/PYTHON/NUMPY/numpy-1.7.0/build/src.linux-x86_64-2.7/numpy/core/include/numpy/
#+END_EXAMPLE
6. Compile: 
#+BEGIN_SRC sh
python setup.py build_ext --inplace
#+END_SRC
Note: for MASSIVE users the default gcc produces errors. Use =module load gcc/4.7.2 mpfr/3.1.2  gmp/5.1.1=


** Profiling
At the top of filterkspace.pyx. place this:
#+BEGIN_EXAMPLE
# cython: profile=True
#+END_EXAMPLE


speed up type definitions in function arguments
#+BEGIN_SRC python
...
def fouriergauss(np.ndarray[DTYPE_t, ndim=1] siz, np.ndarray[NP_FLOAT_t, ndim=1] sigma):
...
    cdef np.ndarray[DTYPE_t, ndim=1] sz = np.ceil(np.array(siz) / 2.0)
    cdef np.ndarray[DTYPE_t, ndim=1] xx = np.array(range(-int(sz[0]), int(sz[0])))
    cdef np.ndarray[DTYPE_t, ndim=1] yy = np.array(range(-int(sz[1]), int(sz[1])))
    cdef np.ndarray[DTYPE_t, ndim=1] zz
    cdef DTYPE_t maxlen = ndimage.maximum(np.array(siz))
    cdef np.ndarray[NP_FLOAT_t, ndim=3] mult_fact, uu, vv, ww
#+END_SRC

Disable numpy specific bounds checking

http://docs.cython.org/src/tutorial/numpy.html
#+BEGIN_SRC python
cimport cython
@cython.boundscheck(False) # turn of bounds-checking for entire function
def fouriercoords(np.ndarray[DTYPE_t, ndim=1] siz):
...
@cython.boundscheck(False) # turn of bounds-checking for entire function
def fouriergauss(np.ndarray[DTYPE_t, ndim=1] siz, np.ndarray[NP_FLOAT_t, ndim=1] sigma):
#+END_SRC
